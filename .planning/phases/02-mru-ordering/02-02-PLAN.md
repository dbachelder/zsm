---
phase: 02-mru-ordering
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [src/state.rs, src/session/manager.rs]
autonomous: true
---

<objective>
Implement MRU timestamp tracking and apply sorting based on config.

Purpose: Sessions appear in most-recently-used order when sort_order is MRU.
Output: Working MRU sorting with persistent timestamp storage across plugin reloads.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mru-ordering/02-01-SUMMARY.md

@src/config.rs
@src/state.rs
@src/session/manager.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MRU timestamp tracking to SessionManager</name>
  <files>src/session/manager.rs</files>
  <action>
Add timestamp tracking to SessionManager:

1. Add `mru_timestamps: HashMap<String, u64>` field to track unix timestamps per session name
2. Add method `record_switch(&mut self, session_name: &str)` that:
   - Gets current unix timestamp (use `std::time::SystemTime`)
   - Stores it in mru_timestamps HashMap
3. Add method `set_mru_timestamps(&mut self, timestamps: HashMap<String, u64>)` to restore from file
4. Add method `mru_timestamps(&self) -> &HashMap<String, u64>` getter
5. Add method `get_mru_rank(&self, session_name: &str) -> u64` that returns:
   - The timestamp if present
   - 0 if not present (lowest priority)

Note: SystemTime works in WASM via WASI time syscalls - this is safe in Zellij's environment.
  </action>
  <verify>cargo build --target wasm32-wasip1 succeeds</verify>
  <done>
- SessionManager has mru_timestamps HashMap
- record_switch() stores unix timestamp for session name
- Getter methods exist for timestamps and MRU rank
  </done>
</task>

<task type="auto">
  <name>Task 2: Persist and restore MRU timestamps</name>
  <files>src/state.rs</files>
  <action>
Add file persistence for MRU timestamps via run_command (WASM sandbox requires shelling out):

1. Add method `write_mru_timestamp(session_name: &str, timestamp: u64)` that:
   - Uses `run_command` to append to `/tmp/zsm-mru-timestamps`
   - Format: one line per entry: `session_name:timestamp`
   - Run: `echo "name:ts" >> /tmp/zsm-mru-timestamps`
   - Context key: `zsm_internal: "mru_write"`

2. Add method `request_mru_timestamps_read()` that:
   - Uses `run_command` to read `/tmp/zsm-mru-timestamps`
   - Run: `cat /tmp/zsm-mru-timestamps 2>/dev/null || echo ""`
   - Context key: `zsm_read_mru: "true"`

3. In `handle_item_selection()` after the switch case (line ~486-492):
   - Before calling `switch_session`, call `self.session_manager.record_switch(&name)`
   - Call `Self::write_mru_timestamp(&name, timestamp)`

4. Add public method `set_mru_timestamps(&mut self, data: &str)` that:
   - Parses lines of format `name:timestamp`
   - Builds HashMap and calls `self.session_manager.set_mru_timestamps()`
   - Called from main.rs when RunCommandResult arrives with zsm_read_mru context

5. In main.rs, add handling for zsm_read_mru context in RunCommandResult processing
   (follow pattern of zsm_read_previous handling around line 90-95)

6. Call `request_mru_timestamps_read()` in `update_sessions()` when session changes (alongside existing `request_previous_session_read()`)
  </action>
  <verify>cargo build --target wasm32-wasip1 succeeds</verify>
  <done>
- MRU timestamps written to /tmp/zsm-mru-timestamps on session switch
- MRU timestamps read back on plugin load/session change
- Data flows from file to SessionManager's HashMap
  </done>
</task>

<task type="auto">
  <name>Task 3: Apply sorting in combined_items()</name>
  <files>src/state.rs</files>
  <action>
Modify `combined_items()` to sort based on config:

1. After building the `items` Vec (before return on line 200), apply sorting:
   - If `self.config.sort_order == SortOrder::Mru`:
     - Sort ExistingSession and ResurrectableSession items by MRU timestamp (descending - most recent first)
     - Directory items stay in their current position (after sessions, sorted by zoxide score)
   - If `self.config.sort_order == SortOrder::Alphabetical`:
     - Sort ExistingSession and ResurrectableSession items alphabetically by name
     - Directory items stay in their current position

2. Implementation approach:
   - Partition items into sessions (Existing + Resurrectable) and directories
   - Sort sessions based on config
   - Concatenate: sorted sessions + directories
   - This preserves the "sessions first, then directories" structure

3. For MRU sorting, use `session_manager.get_mru_rank()` to get timestamp
   - Higher timestamp = more recent = appears first
   - Sessions without timestamps (rank 0) appear last in the session section
  </action>
  <verify>
cargo build --target wasm32-wasip1 succeeds
cargo clippy --target wasm32-wasip1 -- -D warnings passes
  </verify>
  <done>
- combined_items() sorts sessions by MRU or alphabetically based on config
- MRU sorting places most recently switched sessions first
- Alphabetical sorting orders sessions by name
- Directory items remain after sessions, ordered by zoxide score
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --target wasm32-wasip1` succeeds
- [ ] `cargo clippy --target wasm32-wasip1 -- -D warnings` passes
- [ ] `cargo fmt --check` passes
- [ ] `cargo test` passes (native target for tests)
</verification>

<success_criteria>

- MRU timestamps tracked when switching sessions
- Timestamps persist to /tmp/zsm-mru-timestamps
- Timestamps restore on plugin reload
- Sessions sorted by MRU when config is "mru" (default)
- Sessions sorted alphabetically when config is "alphabetical"
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-mru-ordering/02-02-SUMMARY.md`
</output>
